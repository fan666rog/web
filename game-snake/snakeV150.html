<!DOCTYPE html>
<html>

<head>
  <title>貪食蛇</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      background: linear-gradient(to right, #89f7fe, #66a6ff);
      text-align: center;
      font-family: 'Poppins', 'Microsoft YaHei', sans-serif;
      color: #333;
    }

    h1 {
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }

    canvas {
      background-color: #ffffff;
      border: none;
      border-radius: 0;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      width: 90%;
      max-width: 800px;
      aspect-ratio: 1 / 1;
      display: block;
      margin: 20px auto;
    }

    #scoreboard, #blueDotTimer {
      font-size: 1.2em;
      margin-top: 15px;
      color: #fff;
      font-weight: 600;
    }

    button {
      background: #ff7e5f;  /* fallback for old browsers */
      background: -webkit-linear-gradient(to right, #feb47b, #ff7e5f);  /* Chrome 10-25, Safari 5.1-6 */
      background: linear-gradient(to right, #feb47b, #ff7e5f); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
      border: none;
      color: white;
      padding: 12px 25px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      font-family: 'Poppins', 'Microsoft YaHei', sans-serif;
      margin: 10px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }

    button:disabled {
      background: #bdc3c7;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    /* 遊戲說明樣式 */
    #gameInstructions {
      border: none;
      border-radius: 10px;
      padding: 20px;
      margin: 20px auto;
      width: 80%;
      max-width: 400px;
      background-color: rgba(255, 255, 255, 0.9);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      display: none;
      /* 預設隱藏 */
      text-align: left;
    }
    
    #gameInstructions h2 {
        text-align: center;
    }

    #blueDotTimer { /* 藍色點計時器樣式 */
      font-size: 1.2em;
      font-weight: 600;
      color: #fff;
      display: none; /* 預設隱藏 */
    }

    /* Modal styles */
    #gameOverModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: white;
      padding: 30px 40px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .modal-content h2 {
      margin-top: 0;
      color: #333;
    }

    #touchControls {
        display: none; /* Hidden by default, shown via media query */
        margin-top: 20px;
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10+ */
        user-select: none; /* Standard syntax */
    }

    .d-pad {
        display: grid;
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(3, 60px);
        gap: 5px;
        justify-content: center;
    }

    .d-pad-btn {
        background: rgba(255, 255, 255, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        color: white;
        font-size: 24px;
        font-weight: bold;
        border-radius: 10px;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .d-pad-btn:active {
        background: rgba(255, 255, 255, 0.5);
    }

    .d-pad-up { grid-area: 1 / 2 / 2 / 3; }
    .d-pad-left { grid-area: 2 / 1 / 3 / 2; }
    .d-pad-right { grid-area: 2 / 3 / 3 / 4; }
    .d-pad-down { grid-area: 2 / 2 / 3 / 3; }

    /* Show on smaller screens */
    @media (max-width: 768px) {
        #touchControls {
            display: block;
        }
        .d-pad-down { grid-area: 3 / 2 / 4 / 3; } /* Fix for 3x3 grid */
    }
  </style>
</head>

<body>

  <h1>貪食蛇</h1>

  <div>
    <button id="startGameBtn">開始遊戲</button>
    <button id="pauseBtn" disabled>暫停/繼續</button>
    <button id="instructionsBtn">遊戲說明</button>
  </div>

  <canvas id="myCanvas"></canvas>
  <div id="blueDotTimer">藍色點剩餘時間：<span id="blueDotTime">0</span> 秒</div>
  <div id="scoreboard">分數：0</div>
  <div id="gameInstructions">
    <h2>遊戲說明</h2>
    <p>使用方向鍵控制蛇的移動方向。</p>
    <p>吃到紅色食物可以得分並增長蛇的長度。</p>
    <p>吃到藍色點可以消除2-5格障礙物(亂數)。</p>
    <p>當有障礙物時，藍色的點不定時出現，而且有時效性!</p>
    <p>避免撞到牆壁、自己或障礙物。</p>
  </div>

  <div id="gameOverModal" style="display: none;">
    <div class="modal-content">
        <h2>遊戲結束!</h2>
        <p>你的分數是: <span id="finalScore">0</span></p>
        <button id="playAgainBtn">再玩一次</button>
    </div>
  </div>

  <div id="touchControls">
    <div class="d-pad">
        <button id="upBtn" class="d-pad-btn d-pad-up">↑</button>
        <button id="leftBtn" class="d-pad-btn d-pad-left">←</button>
        <button id="rightBtn" class="d-pad-btn d-pad-right">→</button>
        <button id="downBtn" class="d-pad-btn d-pad-down">↓</button>
    </div>
  </div>

  <script>
    // 著作權標註
    // 貪食蛇遊戲V1.5
    // 作者：fan666rog&Gemini編著

    // --- DOM Elements ---
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const startGameBtn = document.getElementById('startGameBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const instructionsBtn = document.getElementById('instructionsBtn');
    const gameInstructions = document.getElementById('gameInstructions');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScore = document.getElementById('finalScore');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const upBtn = document.getElementById('upBtn');
    const downBtn = document.getElementById('downBtn');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');

    // --- Game State ---
    let snake;
    let dx;
    let dy;
    let foodX, foodY;
    let score;
    let gameRunning;
    let gameLoopInterval;
    let obstacles;
    let blueDotX, blueDotY;
    let blueDotTimer;
    let blueDotVisible;

    // --- Game Constants ---
    const gridSize = 40; // The game is on a 40x40 grid
    let snakeSize; // The size of one grid unit in pixels, will be calculated dynamically

    // --- Game Setup ---
    function setupCanvas() {
        const displayWidth = canvas.clientWidth;
        canvas.width = displayWidth;
        canvas.height = displayWidth;
        snakeSize = canvas.width / gridSize;

        // Redraw game if it's running
        if (gameRunning) {
            drawGame();
        }
    }

    function generateFood() {
      let overlap;
      do {
        overlap = false;
        const foodGridX = Math.floor(Math.random() * gridSize);
        const foodGridY = Math.floor(Math.random() * gridSize);
        foodX = foodGridX * snakeSize;
        foodY = foodGridY * snakeSize;
        
        snake.forEach(segment => {
          if (segment.x === foodX && segment.y === foodY) {
            overlap = true;
          }
        });
        obstacles.forEach(obstacle => {
          if (obstacle.x === foodX && obstacle.y === foodY) {
            overlap = true;
          }
        });
      } while (overlap);
    }

    function generateObstacle() {
      const obstacleLength = Math.floor(Math.random() * 5) + 3;
      const obstacleType = Math.floor(Math.random() * 2);
      let obstacleGridX, obstacleGridY;
      let overlap;
      let attempts = 0;
      do {
        overlap = false;
        obstacleGridX = Math.floor(Math.random() * gridSize);
        obstacleGridY = Math.floor(Math.random() * gridSize);
        
        for (let i = 0; i < obstacleLength; i++) {
          let x, y;
          if (obstacleType === 0) { // Line
            x = (obstacleGridX + i) * snakeSize;
            y = obstacleGridY * snakeSize;
          } else { // Block
            x = (obstacleGridX + (i % 3)) * snakeSize;
            y = (obstacleGridY + Math.floor(i / 3)) * snakeSize;
          }

          if (x >= canvas.width || y >= canvas.height) {
              overlap = true;
              break;
          }

          snake.forEach(segment => { if (segment.x === x && segment.y === y) overlap = true; });
          if (x === foodX && y === foodY) overlap = true;
          obstacles.forEach(obstacle => { if (obstacle.x === x && obstacle.y === y) overlap = true; });
          if (overlap) break;
        }
        attempts++;
      } while (overlap && attempts < 100);

      if (attempts >= 100) return;

      for (let i = 0; i < obstacleLength; i++) {
        if (obstacleType === 0) {
          obstacles.push({ x: (obstacleGridX + i) * snakeSize, y: obstacleGridY * snakeSize });
        } else {
          obstacles.push({ x: (obstacleGridX + (i % 3)) * snakeSize, y: (obstacleGridY + Math.floor(i / 3)) * snakeSize });
        }
      }
    }

    function generateBlueDot() {
      if (obstacles.length >= 2 && !blueDotVisible) {
        let overlap;
        do {
          overlap = false;
          const blueDotGridX = Math.floor(Math.random() * gridSize);
          const blueDotGridY = Math.floor(Math.random() * gridSize);
          blueDotX = blueDotGridX * snakeSize;
          blueDotY = blueDotGridY * snakeSize;

          snake.forEach(segment => { if (segment.x === blueDotX && segment.y === blueDotY) overlap = true; });
          obstacles.forEach(obstacle => { if (obstacle.x === blueDotX && obstacle.y === blueDotY) overlap = true; });
        } while (overlap);
        blueDotVisible = true;
        blueDotTimer = 10 + Math.random() * 5;
      }
    }

    // --- Drawing ---
    function drawRoundRect(x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
    }

    function drawBlueDot() {
      if (blueDotVisible) {
        ctx.fillStyle = '#0077ff';
        drawRoundRect(blueDotX, blueDotY, snakeSize, snakeSize, snakeSize / 4);
        document.getElementById('blueDotTimer').style.display = 'block';
        document.getElementById('blueDotTime').textContent = blueDotTimer.toFixed(1);
      } else {
        document.getElementById('blueDotTimer').style.display = 'none';
      }
    }

    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#ff4757';
      ctx.beginPath();
      ctx.arc(foodX + snakeSize / 2, foodY + snakeSize / 2, snakeSize / 2.2, 0, 2 * Math.PI);
      ctx.fill();

      snake.forEach(function (part, index) {
        ctx.fillStyle = index === 0 ? '#2ed573' : '#2ecc71';
        drawRoundRect(part.x, part.y, snakeSize, snakeSize, snakeSize / 4);

        if (index === 0) {
            ctx.fillStyle = 'white';
            const eyeSize = snakeSize / 5;
            if (dx > 0) { // Right
                ctx.fillRect(part.x + snakeSize - eyeSize * 2, part.y + eyeSize, eyeSize, eyeSize);
                ctx.fillRect(part.x + snakeSize - eyeSize * 2, part.y + snakeSize - eyeSize * 2, eyeSize, eyeSize);
            } else if (dx < 0) { // Left
                ctx.fillRect(part.x + eyeSize, part.y + eyeSize, eyeSize, eyeSize);
                ctx.fillRect(part.x + eyeSize, part.y + snakeSize - eyeSize * 2, eyeSize, eyeSize);
            } else if (dy > 0) { // Down
                ctx.fillRect(part.x + eyeSize, part.y + snakeSize - eyeSize * 2, eyeSize, eyeSize);
                ctx.fillRect(part.x + snakeSize - eyeSize * 2, part.y + snakeSize - eyeSize * 2, eyeSize, eyeSize);
            } else { // Up
                ctx.fillRect(part.x + eyeSize, part.y + eyeSize, eyeSize, eyeSize);
                ctx.fillRect(part.x + snakeSize - eyeSize * 2, part.y + eyeSize, eyeSize, eyeSize);
            }
        }
      });
      
      ctx.fillStyle = '#34495e';
      obstacles.forEach(obstacle => {
        drawRoundRect(obstacle.x, obstacle.y, snakeSize, snakeSize, snakeSize / 5);
      });

      drawBlueDot();
      document.getElementById('scoreboard').textContent = "分數：" + score;
    }

    // --- Game Logic ---
    function checkGameOver() {
      const head = snake[0];
      if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
        return true;
      }
      for (let i = 1; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) {
          return true;
        }
      }
      for (let i = 0; i < obstacles.length; i++) {
        if (head.x === obstacles[i].x && head.y === obstacles[i].y) {
          return true;
        }
      }
      return false;
    }
    
    function updateBlueDot() {
      if (blueDotVisible) {
        blueDotTimer -= 0.1;
        if (blueDotTimer <= 0) {
          blueDotVisible = false;
          blueDotTimer = 0;
        }
      }
    }
    
    function showGameOverModal() {
        finalScore.textContent = score;
        gameOverModal.style.display = 'flex';
    }

    function gameLoop() {
      if (checkGameOver()) {
        clearInterval(gameLoopInterval);
        gameRunning = false;
        showGameOverModal();
        return;
      }

      const head = { 
          x: snake[0].x + dx, 
          y: snake[0].y + dy 
      };
      snake.unshift(head);

      if (Math.abs(head.x - foodX) < snakeSize / 2 && Math.abs(head.y - foodY) < snakeSize / 2) {
        score++;
        generateFood();
        if (score % 5 === 0) {
          generateObstacle();
        }
      } else {
        snake.pop();
      }

      if (blueDotVisible && Math.abs(head.x - blueDotX) < snakeSize / 2 && Math.abs(head.y - blueDotY) < snakeSize / 2) {
        blueDotVisible = false;
        const obstaclesToRemove = Math.floor(Math.random() * 4) + 2;
        obstacles.splice(0, Math.min(obstaclesToRemove, obstacles.length));
      }
      updateBlueDot();
      drawGame();
    }

    function handleKeyPress(event) {
      const LEFT_KEY = 37;
      const UP_KEY = 38;
      const RIGHT_KEY = 39;
      const DOWN_KEY = 40;
      const keyPressed = event.keyCode;
      const goingUp = dy === -snakeSize;
      const goingDown = dy === snakeSize;
      const goingRight = dx === snakeSize;
      const goingLeft = dx === -snakeSize;

      if (keyPressed === LEFT_KEY && !goingRight) { dx = -snakeSize; dy = 0; }
      else if (keyPressed === UP_KEY && !goingDown) { dx = 0; dy = -snakeSize; }
      else if (keyPressed === RIGHT_KEY && !goingLeft) { dx = snakeSize; dy = 0; }
      else if (keyPressed === DOWN_KEY && !goingUp) { dx = 0; dy = snakeSize; }
    }
    
    function startGame() {
        setupCanvas(); // Setup canvas size and resolution

        // Reset game state
        const startGridX = Math.floor(gridSize / 2);
        const startGridY = Math.floor(gridSize / 2);
        snake = [{ x: startGridX * snakeSize, y: startGridY * snakeSize }];
        dx = snakeSize;
        dy = 0;
        score = 0;
        obstacles = [];
        blueDotVisible = false;
        
        generateFood();
        drawGame();
        
        if (gameLoopInterval) clearInterval(gameLoopInterval);
        gameLoopInterval = setInterval(gameLoop, 100);
        
        // Setup buttons and game state
        gameRunning = true;
        startGameBtn.disabled = true;
        pauseBtn.disabled = false;
        pauseBtn.textContent = '暫停遊戲';

        // Start blue dot generator
        setInterval(generateBlueDot, (25 + Math.random() * 25) * 1000);
    }

    // --- Event Listeners ---
    startGameBtn.addEventListener('click', startGame);
    playAgainBtn.addEventListener('click', function() {
        gameOverModal.style.display = 'none';
        startGame();
    });

    pauseBtn.addEventListener('click', function () {
      if (gameRunning) {
        clearInterval(gameLoopInterval);
        gameRunning = false;
        pauseBtn.textContent = '繼續遊戲';
      } else {
        gameLoopInterval = setInterval(gameLoop, 100);
        gameRunning = true;
        pauseBtn.textContent = '暫停遊戲';
      }
    });

    instructionsBtn.addEventListener('click', function () {
      gameInstructions.style.display = gameInstructions.style.display === 'none' ? 'block' : 'none';
    });

    window.addEventListener('keydown', handleKeyPress);

    upBtn.addEventListener('click', () => {
        const goingDown = dy === snakeSize;
        if (!goingDown) { dx = 0; dy = -snakeSize; }
    });
    downBtn.addEventListener('click', () => {
        const goingUp = dy === -snakeSize;
        if (!goingUp) { dx = 0; dy = snakeSize; }
    });
    leftBtn.addEventListener('click', () => {
        const goingRight = dx === snakeSize;
        if (!goingRight) { dx = -snakeSize; dy = 0; }
    });
    rightBtn.addEventListener('click', () => {
        const goingLeft = dx === -snakeSize;
        if (!goingLeft) { dx = snakeSize; dy = 0; }
    });

    window.addEventListener('resize', () => {
        setupCanvas();
        // Also need to reposition snake and food if game is not running
        if (!gameRunning) {
             drawGame(); // Or a special "draw static" function
        }
    });

    // Initial setup
    setupCanvas();

  </script>

</body>

</html>